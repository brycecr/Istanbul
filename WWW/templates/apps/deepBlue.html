<head>
	%include templates/parts/head.html
</head>
<body>

	%include templates/parts/navBar.html

	<div class="container">

        <div id="pageHeader">
            <div id="title">Deep Blue</div>
        </div>

		<hr>

		<div class="appMedia">
			<ul class="thumbnails">
				<li>
					<div class="thumbnail">
						<iframe width="450" height="280" src="http://www.youtube.com/embed/NJarxpYyoFI" frameborder="0" allowfullscreen></iframe>
					</div>
				</li>
        <li>
          <div class=thumbnail">
            <img src="../img/turk.jpg" style="margin-bottom:10px; width=450px; height=280px;"></img>
          </div>
        </li>
			</ul>
		</div>

		<div class="section">
			<p class="header lead">
				The Story
			</p>
			<div class="row">
				<div class="span8">
					<p>
          For much of modern history, chess playing has been seen as a "litmus test" of the ability for computers to act intelligently. In 1770, the Hungarian inventor Wolfgang von Kempelen unveiled <a href="http://en.wikipedia.org/wiki/The_Turk">"The Turk"</a>, a (fake) chess-playing machine. Although the actual machine worked by allowing a human chess player to sit inside of it and decide the machine's moves, audiences around the world were fascinated by the idea of a machine that could perform intelligent tasks at the same level as humans.
					</p>
          <p>
          With the advent of computers in the 1940s, researchers and hobbyists began the first serious attempts at making an intelligent chess-playing machine. In 1950, Claude Shannon published a groundbreaking paper entitled <a href="http://vision.unipv.it/IA1/ProgrammingaComputerforPlayingChess.pdf">"Programming a Computer for Playing Chess"</a>, which first put forth the idea of a function for evaluating the efficacy of a particular move and a "minimax" algorithm which took advantage of this evaluation function by taking into account the efficacy of future moves that would be made available by any particular move. This work provided a framework for all future research in computer chess playing.
          </p>
          <p>
          As was the case with many subfields of Artificial Intelligence at this time, progress in the development of chess-playing hardware lagged behind the theoretical frameworks developed in the 60s and 70s, building on Shannon's work. The public was doubtful that a machine would ever be able to defeat a proficient human chess player. Chessmaster and computer chess pioneer David Levy famously made the following statement in 1968: "Prompted by the lack of conceptual progress over more than two decades, I am tempted to speculate that a computer program will not gain the title of International Master before the turn of the century and that the idea of an electronic world champion belongs only in the pages of a science fiction book."
          </p>
          <p>
          In the mid-1990s, however, the tides began to change. Despite the lingering skepticism of the chess community (when asked to confirm his belief that Garry Kasparov could beat any existing computer chess program, Levy stated, "I'm positive. I'd stake my life on it"), chess-playing computers began to beat extremely proficient chess players in exhibition matches. The turning point came in 1997, when Chessmaster Garry Kasparov faced off against IBM's chess-playing computer Deep Blue in New York, NY in an official match under tournament regulations. Despite having lost a previous match against Kasparov in 1996, Deep Blue won the 1997 match 3.5 to 2.5 and became the first computer program to defeat a world chess champion in match play.
          </p>
          <p>
          Since the seminal 1997 victory, chess-playing computer programs have built upon Deep Blue's developments to become even more proficient and efficient. Nowadays, one can run chess programs even more advanced than Deep Blue on a standard desktop or laptop computer.
          </p>
				</div>
				<div class="span4">
					<div class="faq well">
						<img src="http://www.nyu.edu/pages/linguistics/courses/v610003/shannon.gif" style="margin-bottom:10px;"></img>
						<p>
							Claude Shannon
						</p>
            <img src="http://www.thechessdrum.net/newsbriefs/2002/NB_photos/Kasparov-DeepBlue.jpg" style="margin-bottom:10px;"></img>
            <p>
              Garry Kasparov vs. Deep Blue
            </p>
					</div>
				</div>
			</div>
		</div>

		<div class="section">
			<p class="header lead">
				AI Techniques
			</p>
			<div class="row">
				<div class="span8">
					<div class="subsection">
						<h4 class="subheading">Tree Search</h4>
						<p>
						The basic model of chess is that of a Tree Search problem, where each state is a particular arrangement of the pieces on the board and the available actions correspond to the legal chess moves for the current player in that arrangement. An example "slice" of such a tree is given in the following figure:
						</p>
						<img src="http://garabedyan.files.wordpress.com/2011/04/chess-shannon-type-a.png"></img>
            <p>
						Once we have modeled the game in this way, we can begin applying our algorithms from this course to the problem!
            </p>
					</div>

					<div class="subsection">
						<h4 class="subheading">The Evaluation Function</h4>
						<p>As put forth in Shannon's paper, the primary ingredient in a chess-playing program is the evaluation function. Since we can't look forward all the way to the end of the game and see if a particular move will win (especially since we don't know what the other player will do during their turns!), we must create a function which takes in a state of the game (in our case, a board arrangement) and boils it down to a real-number evaluation of the state. For example, the function could give higher scores to board states in which the player of interest has more of their pieces on the board than the opponent. In particular, we would probably want the function to assign an extremely high score (perhaps even infinity) to the board arrangement in which the opponent's king is in checkmate, meaning that the player of interest is guaranteed to win the game.</p>
            <img src="../img/evaluation.png"></img>
					</div>
          
          <div class="subsection">
            <h4 class="subheading">The Minimax Algorithm</h4>
            <p>Given an evaluation, all that's left is a way of actually choosing which move to take. Although looking ahead one step and simply choosing the move which leads to the board arrangement with the highest evaluation score would be a good baseline, we can be even smarter and take into account the actions our opponent could take once we've moved. This intuition leads to the "Minimax algorithm", so-called because we choose the action which <i>minimizes</i> our <i>maximum</i> possible "loss" from making a particular move. Specifically, for each move we could make we look ahead as many steps as our computing power will allow and examine all the possible moves our opponent could make in each of their future turns, given that we've made our original move. We then take the maximum "loss" (equivalently, the minimum of our evaluation function) that our opponent could induce for us via their moves, and we choose the move we could make which minimizes this maximum.
            </p>
          </div>
          
          <div class="subsection">
            <h4 class="subheading">Heuristics/Optimizations</h4>
            <p>Equipped with an evaluation function and an implementation of the minimax algorithm, one can already design an incredibly effective chess-playing program. However, the "big time" programs build even further upon these by implementing "heuristics", simple rules which can cut down on computation time, along with optimizations of the minimax algorithm, given the specific structure of chess. An example heuristic could be that if a move leads to the player's king being in checkmate, then the algorithm should not look any farther down that path of the game tree, since we know the player will never want to make that move. A popular optimization of minimax is known as <a href="http://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning">Alpha-beta pruning</a>, wherein any move for which another move has already been discovered that is guaranteed to do better than it is eliminated. For example, in the following tree we do not need to explore any of the paths whose edges are crossed-out, since we've already found moves we know will perform better:
            </p>
            <img src="http://pages.cs.wisc.edu/~dyer/cs540/notes/gametree.gif"></img>
				</div>
      </div>
    </div>

		<div class="section">
				<p class="header lead">
					Get Involved
				</p>
				<p>
					If you want to work on similar problems, there are many great resources both on the internet and here at Stanford that you can take advantage of! Stanford professor <a href="http://logic.stanford.edu/people/genesereth/genesereth.html">Michael Genesereth</a> has a course available on Coursera entitled <a href="https://www.coursera.org/course/ggp">"General Game Playing"</a>, which delves deeply into the algorithmic and logical foundations of chess-playing computer programs. If you are at Stanford, the course is offered as <a href="http://logic.stanford.edu/classes/cs227/2013/index.html">CS227B</a> and is taught each Spring quarter. For a foray into the specific methods utilized by chess-playing programs, the aforementioned David Levy has a book encompassing a vast range of such techniques entitled <a href="http://www.amazon.com/books/dp/487187804X">"Computer Chess Compendium"</a>. Lastly, you should pay particular attention to the Search portion of this class, as almost all modern programs boil down to simple implementations of A* search and/or minimax search with fancy chess-specific heuristics and optimizations!
				</p>
			</div>

			%include templates/parts/footer.html

		</div>
</body>
